"use strict";
/**
 * Since only a single constructor is being exported as module.exports this comment isn't documented.
 * The class and module are the same thing, the contructor comment takes precedence.
 * @module request-helper
 */
 
var EventEmitter = require('events').EventEmitter;
var util = require('util');
 
/**
 * Creates a helper class used to send multiple messages back and forth across a read stream and a write stream
 * Terminates each complete message with a white space padded 4 character request ID, folloed by an ASCII Group Separator
 * @constructor
 * @param inStream { Stream } - The stream read from the process instantiating the helper
 * @param outStream { Stream } - The stream written to from the process instantiating the helper
 * @param evenRequestIds { boolean } - If true; then request ids generated from this helper will be even; else odd
 * @example var requestHelper = new (require(request-helper))(process.stdin, process.stdout, true);
 */
 module.exports = function RequestHelper(inStream, outStream, evenRequestIds) {
    //Protect the constructor from being called as a normal method
    if (!(this instanceof RequestHelper)) {
        return new RequestHelper(inStream, outStream, evenRequestIds);
    }
    EventEmitter.call(this);

    this.inStream = inStream;
    this.outStream = outStream;
    this.nextRequestId = evenRequestIds ? 2 : 1;
    this.generateEvenRequestIds = evenRequestIds;
    this.currentInput = '';
    
    var requestHelper = this;
    inStream.on( 'data', function (chunk) {
        //Just keep reading that stdin, the source is the trusted responsible one. We're expecting to load everything into memory
        //TODO limit the amount of stdin which can be read
        requestHelper.currentInput += chunk;
        
        //Check if message is complete
        if (requestHelper.currentInput.indexOf('\u0029', requestHelper.currentInput.length - 1) !== -1) {
            //Message ended
            //Parse the requestId, which is padded left padded with spaces to 4 characters
            var requestId = parseInt(requestHelper.currentInput.substring(requestHelper.currentInput.length - 4, requestHelper.currentInput.length - 1));
            //Strip the control character and the requestId
           var msgBody = requestHelper.currentInput.substring(0, requestHelper.currentInput.length - 5)
           
           //emit the request to everyone listening for new incoming requests
           var evenRequestId = requestId % 2 === 0;
           if ( evenRequestId === requestHelper.generateEvenRequestIds) {
           
               //The requestId was generated by this helper (meaning it is a response)
               requestHelper.emit('response'+requestId, msgBody);
           } else {
              //The requestId should have been generated by the oposite helper we're communicating with (meaning it is a new request)
              requestHelper.emit('request', requestId, msgBody);
           }
           requestHelper.currentInput = '';
        }
        
    });
    
};

util.inherits(module.exports, EventEmitter);

/**
 * Request event
 *
 * @event request
 * @type { string }
 * @property {integer} requestId - The 
 */

/**
 * Stream see [NodeJS Stream] {@link https://nodejs.org/api/stream.json}
 * @typedef {Object} Stream
 */

/**
 * This callback is displayed as a global member.
 * @callback responseCallback
 * @param {string} responseMessage
 */
 
/**
 * Pipes a new request into our managed output stream
 * @method pipeRequest
 * @param {module:request-helper~Stream} stream - The stream to pipe and decorate with a requestId
 * @param {module:request-helper~responseCallback} [callback] - A callback to use if this requestHelper receives a response with the same requestId
 */
module.exports.prototype.pipeRequest = function(stream, callback) {
    //TODO if there is a currently un-ended stream writing, queue this stream
    var requestHelper = this;
    //Pipe, but of course don't close our destination
    stream.pipe(this.outStream, { end: false });
    stream.on('end', function(){
        //The stream ended, write out the next 
      requestHelper.outStream.write(("    " + requestHelper.nextRequestId).slice(-4) + '\u0029');
      if (!!callback) {
          //callback provided, listen for a response
          requestHelper.once('response' + requestHelper.nextRequestId, callback);
      }
      //increment the requestId to the next even or odd number
      requestHelper.nextRequestId = requestHelper.nextRequestId + 2;
        //TODO dequeu any waiting streams
    });
};

/**
 * Writes a new request into our managed output stream
 * @method writeRequest
 * @param {string} msgBody - The body of the request
 * @param {module:request-helper~responseCallback} [callback] - A callback to use if this requestHelper receives a response with the same requestId
 */
module.exports.prototype.writeRequest = function(msgBody, callback) {
    //TODO if there is a currently un-ended stream writing, queue this write
    //Write the message body and requestId
    this.outStream.write(msgBody +("    " + this.nextRequestId).slice(-4) + '\u0029');
    if (!!callback) {
        //callback provided, listen for a response
        this.once('response' + this.nextRequestId, callback);
    }
    //increment the requestId to the next even or odd number
    this.nextRequestId = this.nextRequestId + 2;
};

/**
 * Writes a new request into our managed output stream
 * @method writeRequest
 * @param {integer} requestId - The request to send a response for
 * @param {string} msgBody - The body of the request
 */
module.exports.prototype.writeResponse = function(requestId, msgBody) {
    //TODO if there is a currently un-ended stream writing, queue this write
    //Write the message body and requestId
    this.outStream.write(msgBody +("    " + requestId).slice(-4) + '\u0029');
};